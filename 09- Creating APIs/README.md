# ساختن APIها

در این فصل ما در مورد مباحث زیر بحث خواهیم کرد:

- RESTful API
- طراحی API
- فریمورک رست جنگو
- الگوهای API

تا کنون اپلیکیشن‌های جنگویی که ما طراحی میکردیم مورد استفاده انسان‌ها قرار میگرفت اما، حالا خیلی از آن‌ها به وسیله اپلیکیشن‌های دیگر دیگر مورد استفاده قرار میگیرند که استفاده ماشین با ماشین (machine to machine) است. طراحی خوب API باعث میشه که برنامه‌نویس‌ها برای نوشتن کد استفاده از آن راحت‌تر باشند.


در این فصل، هر موقع از لفظ API استفاده کردیم منظورمان **Representational state transfer (REST)** web APIها است، همانطوری که عموماً هم اشاره می‌شود. APIها معنای محبوبی دارند نه فقط بخاطر دسترسی عملکرد وب اپلیکشن‌ها است اما همچنین بخاطر ترکیب کردن و ساختن اپلیکیشن به طور کامل نیز است.

## RESTful API

اکثر اپلیکشن‌ها و وب سایت‌های محبوب این روزها یک رابط برنامه‌نویسی کاربردی(API) REST یا REST API ارائه میدهند. آمازون، نتفلیکس، تویلیو و هزاران کمپانی دیگه دارای رابط کاربری عمومی هستند که بخش  قابل توجهی از رشد تجارت آن‌ها شده است.

یک RESTful API یک وب سرویس API است که به ویژگی‌های معماری REST پایبند است. ما به طور خلاصه در [فصل 4]('../../../04-%20Views%20and%20URLs/README.md)، ویو‌ها و  urlها اشاره  کردیم که تز روی فیلدینگ(Roy Fielding) بود که سبک معماری Rest را معرفی کرد. با توجه به سادگی و انعطاف پذیری آن در موارد استفاده مختلف از جمله اپلیکیشن‌های موبایل به یک استاندارد واقعی در صنعت برای رابط‌های برنامه‌نویسی تبدیل شده است.

شش محدودیت معماری برای سیستم خالص RESTful است که آن‌ها در زیر آمده‌اند:

- **کلاینت - سرور**: الزام اینکه کلاینت و سرور باید را به صورت جدا باشند و بتوانند به صورت مستقل تکامل یابند.
- **بی تابعیت(Stateless)**: لازمه REST که بهش بی تابعیت هم میگن اینه که context کلاینت فقط در کلاینت ذخیره بشه ولی در سرور خیر.
- **قابل کش شدن(Cacheable)**: مخصوصا باید پاسخ‌ها(Response) مشخص باشند که قابل کش شدن هستند یا خیر که میتونه مقیاس پذیری و بازدهی را بهبود بده.
- **سیستم لایه‌ای**: به صورت فرم سلسله مراتبی به مدیریت پیچیدگی کمک میکنه و مقیاس پذیری رو بهبود میده.
- **کد بر اساس تقاضا**: به کدها یا اپلت‌ها(applet) اجازه میده که توسط سرور به کلاینت فرستاده بشن.
- **رابط یک شکل(Uniform Interface)**: مجموعه‌ای از محدودیت‌های اساسی است که معماری را جدا می‌کند از جمله منابع و پیام‌های خود توصیف کننده.

هرچند اکثر APIها به صورت خالصانه RESTful نیستند چون آن‌ها ممکنه یک یا چندتا از این محدودیت‌ها را بشکنند(معمولاً هم رابط یک شکل). هرچند هنوز هم ممکنه آن‌ها رو REST API بنامند.

در عمل اکثر آن‌ها به چند مفهوم معماری پایبندند، مانند زیر:

- منابع: هر شئ، داده به وسیله **Uniform Resource Identifiers(URI)** قابل دسترس هستند. این میتونه یک شئ تنها(میتونیم بگیم کاربر) یا یک مجموعه(میتونیم بگیم کاربران) باشه. معمولاً اونا به یک اسم اشاره میکنن تا یک فعل.
- عملیات درخواست: عملیات روی منابع عموماً از عملیات‌های استاندارد HTTP مانند GET, PUT, POST, OPTION و DELETE استفاده می‌شود. آن‌ها از همان قوانین به خوبی پیروی می‌کنند مثلا GET پوچه(بدون عوارض جانبی است) و PUT/DELETE ناتوان‌اند(همیشه همان نتیجه رو میگیرید مهم نیست چندبار آن‌ها را اجرا بشن).
- کدهای خطا: REST API از کدهای خطای HTTP استاندارد مانند 200(موفق)، 300(ریدایرکت) و 400(خطای کاربر) استفاده می‌کند.
- هایپرمدیا: جواب‌ها معمولاً حاوی هایپرلینک یا URIها به دیگر اقدامات(Action) و منابع برای انعطاف پذیری و قابل کشف شدن است. به طور مثال از هایپرلینک‌ها برای صفحه‌بندی(Pagination) یا دیتاهای با ساختار تو در تو استفاده می‌شود.

پیشنهاد من به شما این خواهد بود که استفاده از APIتان را هر چه می‌توانید آسان کنید تا به صورت سختگیرانه از محدودیت‌های REST خالص پیروی کنید. خیلی از APIهای محبوب و شناخته شده آن‌ها را نقص می‌کنند. اگر REST طراحی کردن API از آن روش راحت‌تره، از این روش استفاده کنید.

### طراحی API

ما یک استاندارد تنها برای REST API نداریم. هرچند در طول زمان تعداد زیادی APIهای خوب طراحی شده توسط کمپانی‌هایی مثل استرایپ، گیت‌هاب و ترلو به استاندارد‌هایی تبدیل شده‌اند که اکنون APIهای وب بر اساس آن طراحی می‌شوند. در اینجا ما چندین بهترین شیوه‌(best practice) را علاوه بر اصول طراحی که در بالا ذکر کردیم پوشش می‌دهیم. 


#### ورژن بندی کردن

یک API مثل قراردادی بین سرور و کلاینت است. اگر تغییراتی در رابط(Interface) یا معمولا در سرور صورت بگیرد قرارداد فسخ شده است. هرچند API نیاز دارد که تکامل یابد و ویژگی‌های جدیدی به آن اضافه شود و ویژگی‌های قدیمی آن منسوخ شوند.

از این رو ورژن بندی کردن API تصمیم کلیدی طراحی، در چرخه زندگی آن است که باید زود گرفته شود. چندین پیاده‌سازی محبوب ورژن بندی API وجود دارد:

- ورژن بندی کردن URI: پیشوندی کردن URI با شماره ورژن مانند <http://example.com/v3/superheroes/3>. این روش محبوبی است اما اصول را نقض می‌کند که هر منبع دارای یک URI منحصر به فرد در سراسر ورژن‌ها است.
- ورژن بندی پرس و جوی رشته‌ای(Query String versioning): اضافه کردن یک پرس و جوی رشته‌ای مخصوص هر ورژن به URI مانند <http://example.com/superheroes/3?version=3> . به طور فنی، URI در سراسر ورژن‌ها یکی است اما چنین پاسخ‌هایی در پروکسی‌های وب قدیمی‌تر کش نخواهند شد در نتیجه عملکردی تحقیرآمیز دارد.
- ورژن بندی هدر سفارشی(Custom Header versioning): شامل یک هدر سفارشی در درخواست شما. به عنوان مثال نمونه زیر را در نظر بگیرید
```
    GET /superheroes/3 HTTP/1.1
    Host: example.com
    Accept: application/json
    api-version: 3
```
در حالی که این مورد ممکنه به اصول REST نزدیکتر باشه و تمیزتر ولی این میتونه توی تست بعضی کلاینت‌های وب مثل مرورگر سخت‌تر باشه. هدرهای سفارشی دارای مشخصات بیرونی(outside spec) هستند و ممکنه مشکلات پنهانی را ایجاد کنند و این سبب میشه که دیباگ کردن آن‌ها سخت‌تر باشد.
- ورژن بندی نوع رسانه‌ای(Media Type versioning): استفاده از هدر Accept برای مشخص کردن نوع مدیا سفارشی شده که صریحاً در این ورژن ذکر شده. مثال زیر را در نظر بگیرید
```
    GET /superheroes/3 HTTP/1.1
    Host: example.com
    Accept: application/vnd.superhero-api.v3+json
```
این در حالی است که ممکن است مشکلات تست را نیز داشته باشد مانند هدر سفارشی. این افتخاری است که این روش استاندارد است. ممکنه این خالص‌ترین مدل ورژن بندی REST باشه.

تصمیمات طراحی دیگه‌ای نیز وجود دارد، مثل اینکه کدام طرح‌های ورژن بندی که باید دنبال کنید؟ باید یک افزایش عددی ساده باشد(مانند مثال‌های قبلی)، ورژن بندی مفهومی(مثل فیسبوک)، یا تاریخ انتشار آن(تویلیو)؟ این کاملا شبیه تمرین ورژن بندی محصول است.

سازگاری رو به عقب نیز تصمیم مهمی در چرخه زندگی API است. اینکه چند ورژن قدیمی را نگه دارید؟ اینکه چه چیزی تغییر جزئی یا کلی ورژن را تعیین می‌کند؟ اینکه چگونه ورژن‌های قدیمی‌تر را منسوخ کنیم؟

بهترین کار این که یک سیاست ارتباطی شفاف داشته باشید و همواره ازش پیروی کنید.

