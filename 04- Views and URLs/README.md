# ویوها و URLها

در این فصل ما در مورد مباحث زیر بحث خواهیم کرد:

- ویوهای بر اساس کلاس و بر اساس فانکشن
- میکسین‌ها
- دکوراتورها
- الگوهای مرسوم ویو
- طراحی کردن URLها
- کار کردن با ری‌اکت و دیگر فرانت‌اندهای جاوا اسکریپت

## نگاه از بالا به ویو

در جنگو، ویوها به عنوان فراخوانی کننده تعریف می‌شوند که درخواست‌ها را میپذیرند و پاسخ‌ها را برمی‌گردانند. ویوها معمولاً یک فانکشن یا کلاس به همراه یک متود کلاسی مخصوص مثل ```()as_view``` هستند.

در هر دو مورد ما یک تابع پایتون معمولی میسازیم که ```HTTPRequest``` را به عنوان آرگومان اول می‌گیرد و ```HTTPResponse``` را به عنوان پاسخ برمی‌گرداند.
یک ```URLConf```(پیکربندی URL) نیز همچنین میتواند به عنوان آرگومان اضافه به این تابع فرستاده شود. این آرگومان‌ها می‌تواند از قسمتی از URL گرفته شود و یا مقدار آن به صورت پیشفرض معین شده باشد.

نمونه یک ویوی ساده به شکل زیر است:

```
# In views.py
from django.http import HttpResponse

def hello_fn(request, name="World"):
    return HttpResponse("Hello {}!".format(name))
```

هر دو خط تابع ویو ما انقدر ساده است که راحت میشه آن را متوجه شد. در حال حاضر ما هیچ کاری با آرگومان‌های درخواست فرستاده شده نداریم. میتونیم برای بهتر فهمیدن کانتکس که در کدام ویو صدا زده شده است، می‌توانیم درخواست را بررسی کنیم به طور مثال با نگاه کردن به پارامترهای ```GET/POST```، مسیر URI یا هدرهای HTTP مثل ```REMOTE_ADDR```.

تنظیم نقشه مسیرها در ```URLConf``` به صورت سنتی است که از عبارات منظم استفاده می‌شود که به صورت زیر است:

```
# In urls.py
    url(r'^hello-fn/(?P<name>\w+)/$', views.hello_fn),
    url(r'^hello-fn/$', views.hello_fn),
```
 
برای پشتیبانی کردن از دو الگوی URL میتوانیم از همان ویو مجدداً استفاده کنیم. الگوی اول یک نام را به عنوان آرگومان میگیرد. الگوی دوم هیچ آرگومانی را از URL نمیگیرد و تابع ویو از مقدار پیشفرض معین شده برای نام در این استفاده می‌کند.

وقتی شما از سینتکس مسیریابی شده که در جنگو 2.0 معرفی شد استفاده میکنید، ارسال پارامترها به طور یکسان کار میکند.پس شما نگاشت معادل آن را میتواند در ```viewschapter/urls.py``` پیدا کنید:

```
# In urls.py
    path('hello-fn/<str:name>/', views.hello_fn),
    path('hello-fn/', views.hello_fn),
```

ما در ادامه کتاب از سینتکس ساده شده استفاده می‌کنیم که خواندن آن راحت‌تر است.

### ویوهایی که کلاسی‌تر هستند

ویوهای بر اساس کلاس در جنگو 1.4 معرفی شدند. در اینجا ما معادل تابع ویو قبل را که دیدیم برای ویو بر اساس کلاس بازنویسی کرده‌ایم:

```
from django.views.generic import View


class HelloView(View):
    def get(self, request, name="World"):
        return HttpResponse("Hello {}!".format(name))
```

دوباره در اینجا متناظر با قبل در ```URLConf``` ما دو خط داریم که در زیر آمده است:

```
# In urls.py
    path('hello-cl/<str:name>/', views.HelloView.as_view()),
    path('hello-cl/', views.HelloView.as_view()),
```

چندین تفاوت جالب بین ویوهای بر اساس کلاس و تابع‌های ویو وجود دارد. چیزی که خیلی واضحه این که ما نیاز داریم اول کلاس را تعریف کنیم بعد ما باید صراحتاً فقط درخواست‌های ```GET``` را مدیریت کنیم. در تابع ویو قبلی برای ```POST ،GET``` یا دیگر پروتکل‌های HTTP همان پاسخ را دریافت می‌کنیم. همانطور که در دستورهای زیر از کلاینت در شل جنگو استفاده می‌کنیم:

```
>>> from django.test import Client
>>> c = Client()

>>> c.get("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.get("http://0.0.0.0:8000/hello-cl/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-cl/").content
Method Not Allowed (POST): /hello-cl/
b'
```

به یاد داشته باشید که متود ```POST``` دیگر غیرمجاز است به جای اینکه در سکوت نادیده گرفته شود. صریح بودن از نقطه نظر امنیت و نگه‌داری ویو خوب است.

مهمترین مزیت استفاده از کلاس این است که هنگام شخصی سازی ویو میتوانیم راحت‌تر آن را انجام دهیم. شما می‌توانید از یک کلاس عمومی ویو برای خوش آمدگویی بنویسید و خوش آمدگویی‌های اختصصاصی خود را نیز از آن استخراج کنید مثل زیر:

```
class GreetView(View):
    greeting = "Hello {}!"
    default_name = "World"
    def get(self, request, **kwargs):
        name = kwargs.pop("name", self.default_name)
        return HttpResponse(self.greeting.format(name))

class SuperVillainView(GreetView):
    greeting = "We are the future, {}. Not them. "
    default_name = "my friend"
```

پس ```URLConf``` نشأت گرفته از کلاس به صورت زیر است:

```
# In urls.py
    path('hello-su/<str:name>/', views.SuperVillainView.as_view()),
    path('hello-su/', views.SuperVillainView.as_view()),
```

در صورتی که شما بخواهید چند آرگومان کلمه کلیدی با مقادیر پیشفرضشان به تابع ویو اضافه کنید و شخصی سازی کنید در شیوه مشابه ممکن نیست و این میتونه غیر قابل مدیریت باشه.این دقیقاً همان دلیلی که ویوهای جنریک از تابع‌های ویو به ویوهای بر اساس کلاس مهاجرت کردند.

**جنگو رها شده(داستان)**

استیو بعد از صرف دو هفته زمان برای شکار کردن یه توسعه دهنده خوب جنگو شروع به فکر کردن خلاقانه و متفاوت کرد. متوجه شد که موفقیت بزرگ آن‌ها در رویداد هکاتون، او و هارت یک مسابقه *جنگوی رها شده* را در S.H.I.M سازماندهی کرده‌اند. قوانین آن‌ها بسیار ساده است: ساختن یک وب اپلیکیشن در یک روز. این ممکنه ساده باشه ولی شما نمیتونی یک روز را رد کنی یا زنجیر را بشکنی. هر کسی که طولانی‌ترین زنجیر را بسازه برنده است.

برنده، برد زانی یک سوپرایز واقعی بود. اون یک طراح سنتی بود که هیچ سررشته‌ای از برنامه نویسی نداشت. اون فقط یک بار در کلاس آموزشی یک هفته‌ای جنگو فقط برای ضربه زدن شرکت کرده بود. اون یک زنجیره ناگسستنی از 21 سایت جنگو که همه از صفر ساخته شده بودند را مدیریت کرد.

استیو همان روز بعدش با او ساعت 10 در دفترش قرار ملاقاتی گذاشت. اگر که برد نمیدانست که در فرآیند استخدام قرار گرفته است. در زمان مقرر شده ضربه آرامی شنیده شد و پسری لاغر و ریشو که اواخر بیست سالگی بود وارد شد. همانطور که آن‍ها صحبت میکردند، برد هیچ تظاهری به واقعیت نکرد که یک برنامه‌نویس نیست. در واقع برای او هیچ تظاهر کردنی نبود. با چشمان آرام آبیش به عینک ضخیمش نگاهی انداخت و توضیح داد که رازش خیلی ساده بوده؛ الهام بگیر و تمرکز کن.

او روزش را با یک وایرفریم(طرح اولیه) ساده شروع میکرد بعد می‌خواست یک پروژه جنگو خالی با قالب بوت استرپ توئیتر بسازد. اون ویوهای جنریک بر اساس کلاس جنگو را پیدا کرد که راه عالی‌ای برای بدون به سختی کد نوشتنی برای ساختن ویوها بود. بعضی اوقات او از یک یا دو میکسین‌های جنگو استفاده میکرد و همچنین رابط پنل مدیریت جنگو را برای اضافه کردن داده در هنگام کار کردن دوست داشت.

پروژه مورد علاقه‌اش Labyrinth بود؛ یک هانی پات که به فروم بیس بال مبدل شده بود. او حتی توانست چندین ربات نظارتی که در حال شکار سایت‌های آسیب پذیر بودند را نیز به دام بیاندازد. وقتی که استیو درباره پروژه سوپر کتاب به او توضیح داد، اون خیلی بیشتر خوشحال شد که این پیشنهاد را قبول کنه. ایده ساخت شبکه اجتماعی میان ستاره‌ای واقعاً او را مجذوب خود کرد. با یکمی گشت و گذار بیشتر، استیو میتوانست چند ده پروفایل جذاب مثل برد را در S.H.I.M پیدا کند. او یاد گرفت که در وهله اول به جای گشتن در خارج از مجموعه، بهتر است که اول در داخل سازمان جستجو کند.

# ویوها و URLها

در این فصل ما در مورد مباحث زیر بحث خواهیم کرد:

- ویوهای بر اساس کلاس و بر اساس فانکشن
- میکسین‌ها
- دکوراتورها
- الگوهای مرسوم ویو
- طراحی کردن URLها
- کار کردن با ری‌اکت و دیگر فرانت‌اندهای جاوا اسکریپت

## نگاه از بالا به ویو

در جنگو، ویوها به عنوان فراخوانی کننده تعریف می‌شوند که درخواست‌ها را میپذیرند و پاسخ‌ها را برمی‌گردانند. ویوها معمولاً یک فانکشن یا کلاس به همراه یک متود کلاسی مخصوص مثل ```()as_view``` هستند.

در هر دو مورد ما یک تابع پایتون معمولی میسازیم که ```HTTPRequest``` را به عنوان آرگومان اول می‌گیرد و ```HTTPResponse``` را به عنوان پاسخ برمی‌گرداند.
یک ```URLConf```(پیکربندی URL) نیز همچنین میتواند به عنوان آرگومان اضافه به این تابع فرستاده شود. این آرگومان‌ها می‌تواند از قسمتی از URL گرفته شود و یا مقدار آن به صورت پیشفرض معین شده باشد.

نمونه یک ویوی ساده به شکل زیر است:

```
# In views.py
from django.http import HttpResponse

def hello_fn(request, name="World"):
    return HttpResponse("Hello {}!".format(name))
```

هر دو خط تابع ویو ما انقدر ساده است که راحت میشه آن را متوجه شد. در حال حاضر ما هیچ کاری با آرگومان‌های درخواست فرستاده شده نداریم. میتونیم برای بهتر فهمیدن کانتکس که در کدام ویو صدا زده شده است، می‌توانیم درخواست را بررسی کنیم به طور مثال با نگاه کردن به پارامترهای ```GET/POST```، مسیر URI یا هدرهای HTTP مثل ```REMOTE_ADDR```.

تنظیم نقشه مسیرها در ```URLConf``` به صورت سنتی است که از عبارات منظم استفاده می‌شود که به صورت زیر است:

```
# In urls.py
    url(r'^hello-fn/(?P<name>\w+)/$', views.hello_fn),
    url(r'^hello-fn/$', views.hello_fn),
```
 
برای پشتیبانی کردن از دو الگوی URL میتوانیم از همان ویو مجدداً استفاده کنیم. الگوی اول یک نام را به عنوان آرگومان میگیرد. الگوی دوم هیچ آرگومانی را از URL نمیگیرد و تابع ویو از مقدار پیشفرض معین شده برای نام در این استفاده می‌کند.

وقتی شما از سینتکس مسیریابی شده که در جنگو 2.0 معرفی شد استفاده میکنید، ارسال پارامترها به طور یکسان کار میکند.پس شما نگاشت معادل آن را میتواند در ```viewschapter/urls.py``` پیدا کنید:

```
# In urls.py
    path('hello-fn/<str:name>/', views.hello_fn),
    path('hello-fn/', views.hello_fn),
```

ما در ادامه کتاب از سینتکس ساده شده استفاده می‌کنیم که خواندن آن راحت‌تر است.

### ویوهایی که کلاسی‌تر هستند

ویوهای بر اساس کلاس در جنگو 1.4 معرفی شدند. در اینجا ما معادل تابع ویو قبل را که دیدیم برای ویو بر اساس کلاس بازنویسی کرده‌ایم:

```
from django.views.generic import View


class HelloView(View):
    def get(self, request, name="World"):
        return HttpResponse("Hello {}!".format(name))
```

دوباره در اینجا متناظر با قبل در ```URLConf``` ما دو خط داریم که در زیر آمده است:

```
# In urls.py
    path('hello-cl/<str:name>/', views.HelloView.as_view()),
    path('hello-cl/', views.HelloView.as_view()),
```

چندین تفاوت جالب بین ویوهای بر اساس کلاس و تابع‌های ویو وجود دارد. چیزی که خیلی واضحه این که ما نیاز داریم اول کلاس را تعریف کنیم بعد ما باید صراحتاً فقط درخواست‌های ```GET``` را مدیریت کنیم. در تابع ویو قبلی برای ```POST ،GET``` یا دیگر پروتکل‌های HTTP همان پاسخ را دریافت می‌کنیم. همانطور که در دستورهای زیر از کلاینت در شل جنگو استفاده می‌کنیم:

```
>>> from django.test import Client
>>> c = Client()

>>> c.get("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.get("http://0.0.0.0:8000/hello-cl/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-cl/").content
Method Not Allowed (POST): /hello-cl/
b'
```

به یاد داشته باشید که متود ```POST``` دیگر غیرمجاز است به جای اینکه در سکوت نادیده گرفته شود. صریح بودن از نقطه نظر امنیت و نگه‌داری ویو خوب است.

مهمترین مزیت استفاده از کلاس این است که هنگام شخصی سازی ویو میتوانیم راحت‌تر آن را انجام دهیم. شما می‌توانید از یک کلاس عمومی ویو برای خوش آمدگویی بنویسید و خوش آمدگویی‌های اختصصاصی خود را نیز از آن استخراج کنید مثل زیر:

```
class GreetView(View):
    greeting = "Hello {}!"
    default_name = "World"
    def get(self, request, **kwargs):
        name = kwargs.pop("name", self.default_name)
        return HttpResponse(self.greeting.format(name))

class SuperVillainView(GreetView):
    greeting = "We are the future, {}. Not them. "
    default_name = "my friend"
```

پس ```URLConf``` نشأت گرفته از کلاس به صورت زیر است:

```
# In urls.py
    path('hello-su/<str:name>/', views.SuperVillainView.as_view()),
    path('hello-su/', views.SuperVillainView.as_view()),
```

در صورتی که شما بخواهید چند آرگومان کلمه کلیدی با مقادیر پیشفرضشان به تابع ویو اضافه کنید و شخصی سازی کنید در شیوه مشابه ممکن نیست و این میتونه غیر قابل مدیریت باشه.این دقیقاً همان دلیلی که ویوهای جنریک از تابع‌های ویو به ویوهای بر اساس کلاس مهاجرت کردند.

**جنگو رها شده(داستان)**

استیو بعد از صرف دو هفته زمان برای شکار کردن یه توسعه دهنده خوب جنگو شروع به فکر کردن خلاقانه و متفاوت کرد. متوجه شد که موفقیت بزرگ آن‌ها در رویداد هکاتون، او و هارت یک مسابقه *جنگوی رها شده* را در S.H.I.M سازماندهی کرده‌اند. قوانین آن‌ها بسیار ساده است: ساختن یک وب اپلیکیشن در یک روز. این ممکنه ساده باشه ولی شما نمیتونی یک روز را رد کنی یا زنجیر را بشکنی. هر کسی که طولانی‌ترین زنجیر را بسازه برنده است.

برنده، برد زانی یک سوپرایز واقعی بود. اون یک طراح سنتی بود که هیچ سررشته‌ای از برنامه نویسی نداشت. اون فقط یک بار در کلاس آموزشی یک هفته‌ای جنگو فقط برای ضربه زدن شرکت کرده بود. اون یک زنجیره ناگسستنی از 21 سایت جنگو که همه از صفر ساخته شده بودند را مدیریت کرد.

استیو همان روز بعدش با او ساعت 10 در دفترش قرار ملاقاتی گذاشت. اگر که برد نمیدانست که در فرآیند استخدام قرار گرفته است. در زمان مقرر شده ضربه آرامی شنیده شد و پسری لاغر و ریشو که اواخر بیست سالگی بود وارد شد. همانطور که آن‍ها صحبت میکردند، برد هیچ تظاهری به واقعیت نکرد که یک برنامه‌نویس نیست. در واقع برای او هیچ تظاهر کردنی نبود. با چشمان آرام آبیش به عینک ضخیمش نگاهی انداخت و توضیح داد که رازش خیلی ساده بوده؛ الهام بگیر و تمرکز کن.

او روزش را با یک وایرفریم(طرح اولیه) ساده شروع میکرد بعد می‌خواست یک پروژه جنگو خالی با قالب بوت استرپ توئیتر بسازد. اون ویوهای جنریک بر اساس کلاس جنگو را پیدا کرد که راه عالی‌ای برای بدون به سختی کد نوشتنی برای ساختن ویوها بود. بعضی اوقات او از یک یا دو میکسین‌های جنگو استفاده میکرد و همچنین رابط پنل مدیریت جنگو را برای اضافه کردن داده در هنگام کار کردن دوست داشت.

پروژه مورد علاقه‌اش Labyrinth بود؛ یک هانی پات که به فروم بیس بال مبدل شده بود. او حتی توانست چندین ربات نظارتی که در حال شکار سایت‌های آسیب پذیر بودند را نیز به دام بیاندازد. وقتی که استیو درباره پروژه سوپر کتاب به او توضیح داد، اون خیلی بیشتر خوشحال شد که این پیشنهاد را قبول کنه. ایده ساخت شبکه اجتماعی میان ستاره‌ای واقعاً او را مجذوب خود کرد. با یکمی گشت و گذار بیشتر، استیو میتوانست چند ده پروفایل جذاب مثل برد را در S.H.I.M پیدا کند. او یاد گرفت که در وهله اول به جای گشتن در خارج از مجموعه، بهتر است که اول در داخل سازمان جستجو کند.

## ویوهای جنریک بر اساس کلاس

ویوهای جنریک بر اساس کلاس، ویوهای مرسومی برای پیاده سازی کردن به شیوه شئ گرا (مخصوصاً متود الگوی قالب) برای استفاده مجدد بهتر هستند. من از اطلاح ویوهای جنریک متنفرم و ترجیح میدم آن‌ها را **ویوهای استوک** صدا بزنم، مثل عکس‌های استوک. شما می‌توانید با کمی تغییر و تحول برای اکثر کارهای مرسومی که نیاز دارید از آن‌ها استفاده کنید.

ویوهای جنریک به این دلیل ساخته شده‌اند که توسعه دهنده‌های جنگو احساس میکردند که دارند همان نوع ویوها را در هر پروژه دوباره می‌سازند. تقریباً هر پروژه نیاز به یک صفحه داشت که لیستی از اشیاء(```ListView```)، جزیئات یک شئ(```DetailView```) یا فرمی برای ساختن یک شئ(```CreateView```) را نشان دهند. به دلیل اصل DRY(خودت را تکرار نکن)، این ویوهای با قابلیت استفاده مجدد با جنگو همراه شدند.

جدول مناسبی از ویوهای جنریک در جنگو 2.0 در زیر آمده است:

| توضیحات | نام کلاس | نوع کلاس |
| :---: | :---: | ---: |
|این ویو پدر تمام ویوها است که درستی(سلامت عقل) و ارسال(اعزام) را بررسی می‌کند.|View|پایه(base)|
|این ویو از قالب رندر میگیرد و کلمات کلیدی ```URLConf``` را در درون کانتکس قرار می‌دهد.|TemplateView|پایه(base)|
|این ویو هر درخواست ```GET``` را ریدایرکت می‌کند.|RedirectView|پایه(base)|
|این ویو از آیتم‌های قابل تکرار مثل ```queryset``` رندر میگیرد.|ListView|لیست(List)|
|این ویو، از آیتم بر اساس ```pk```(کلید اصلی) یا ```slug```(آدرس مخصوص آن آیتم) در ```URLConf``` رندر میگیرد.|DetailView|جزئیات(Detail)|
|این ویو از فرم رندر میگیرد و آن را پردازش می‌کند.|FormView|ویرایش(Edit)|
|این ویو از فرم رندر میگیرد و آن را برای ساخت یک شئ جدید پردازش می‌کند.|CreateView|ویرایش(Edit)|
|این ویو از فرم رندر میگیرد و آن را برای ویرایش کردن یک شئ پردازش می‌کند.|UpdateView|ویرایش(Edit)|
|این ویو از فرم رندر میگیرد و برای حذف کردن یک شئ آن را پردازش می‌کند.|DeleteView|ویرایش(Edit)|
|این ویو لیستی از اشیاء را با فیلد ```Date```(تاریخ) رندر میگیرد که آخرین شئ در اول قرار میگیرد و به همین ترتیب. |ArchiveIndexView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year```(سال) که توسط ```URLConf``` به آن داده می‌شود، رندر میگیرد.|YearArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year```(سال) و ```month```(ماه) رندر میگیرد.|MonthArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year```(سال) و شماره ```week```(هفته) رندر میگیرد.|WeekArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year, month```(سال، ماه) و ```Day```(روز) رندر میگیرد.|DayArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء که تاریخ آن‌ها، امروز است را رندر میگیرد.|TodayArchiveView|تاریخ(Date)|
|این ویو شئ‌ای را که با فیلدهای ```Year, month```(سال، ماه) و ```day```(روز) که بر اساس ```pk```(کلید اصلی) یا ```slug```(آدرس مخصوص آن آیتم) مشخص شده است را رندر می‌گیرد.|DateDetailView|تاریخ(Date)|
|این ویو فرم ورود را رندر میگیرد و فرآیند وارد شدن را مدیریت می‌کند.|LoginView|احراز هویت(Auth)|
|این ویو کاربرانی که قبلاً وارد شده اند و هنوز از حساب خود خارج نشده‌اند را خارج کرده و پیام **شما خارج شدید** را به آن‌ها نشان می‌دهد.|LogoutView|احراز هویت(Auth)|
|این مجموعه‌ای از شش ویو است که جریان کار فراموشی رمز عبور و تغییر آن را مدیریت می‌کند.|Password*View|احراز هویت(Auth)|

ما کلاس‌های پایه مثل ```BaseDetailView``` یا میکسین‌ها مانند ```SingleObjectMixin``` اینجا ذکر نکردیم. آن‌ها به عنوان کلاس‌های پدر طراحی شده‌اند و در بیشتر موارد، شما از آن‌ها به صورت مستقیم استفاده نمی‌کنید.

من قویاً توصیه میکنم که مناسب‌ترین ویوی جنریک را انتخاب کنید. به طور مثال به جای استفاده از ```ListView``` می‌توانید همان ویو را با استفاده از ```TemplateView``` پیاده سازی کنید یا حتی ```View```. هر چند که اینطور شما اکثر مزیت‌های استفاده کردن از ویوهای جنریک را از دست می‌دهید.

پس خودتان را با این جدول آشنا کنید و ویو جنریکی که با توجه به نیازتان، بیشترین تطابق را دارد انتخاب کنید. بهترین منبع برای ویوهای جنریک بر اساس کلاس درجه یک به آدرس <http://ccbv.co.uk/> است(اکثر توسعه دهندگان جنگو این آدرس را بخاطر دارند). شما تمام ویژگی‌ها و متودهای هر یک از ویوهایی که اینجا ذکر شد را پیدا خواهید کرد.

### ویوهای بر اساس کلاس همیشه جنریک ویوهای بر اساس کلاس نیستند

اکثر افراد بین ویوهای بر اساس کلاس با ویوهای جنریک بر اساس کلاس گیج می‌شوند. اسم‌های آن‌ها بهم شبیه است ولی یکی نیستند. این منجر به برخی ```misconceptions```(تصورات غلط) شده که در زیر آمده است:

- **فقط ویوهای جنریک هستند که با جنگو همراه شده‌اند**: خوشبختانه این اشتباه است. هیچ جادوی خاصی در ویوهای جنریک بر اساس کلاس نیست که ارائه شده باشد.

شما آزادید که مجموعه ویوهای جنریک بر اساس کلاس خود را منتشر کنید همچنین می‌توانید از کتابخانه‌های واسط مثل```django-vanilla-views```(<http://django-vanilla-views.org/>) فلان استفاده کنید که پیاده‌سازی ساده‌تری نسبت به ویوهای جنریک استاندارد دارند. به خاطر داشته باشید که استفاده از ویوهای جنریک شخصی‌سازی شده ممکن است که کد شما را برای بقیه ناآشنا کند.
- **ویوهای بر اساس کلاس همیشه باید از ویوهای جنریک استخراج شوند**: دوباره میگویم، هیچ چیز جادویی ویوهای جنریک بر اساس کلاس وجود ندارد. اگر چه 90 درصد اوقات، شما کلاس جنریکی مثل ```View``` را پیدا می‌کنید که برای استفاده به عنوان کلاس پایه ایده‌آل است. شما آزادید که ویژگی‌های مشابه خودتان را پیاده‌سازی کنید.

