# ویوها و URLها

در این فصل ما در مورد مباحث زیر بحث خواهیم کرد:

- ویوهای بر اساس کلاس و بر اساس فانکشن
- میکسین‌ها
- دکوراتورها
- الگوهای مرسوم ویو
- طراحی کردن URLها
- کار کردن با ری‌اکت و دیگر فرانت‌اندهای جاوا اسکریپت

## نگاه از بالا به ویو

در جنگو، ویوها به عنوان فراخوانی کننده تعریف می‌شوند که درخواست‌ها را میپذیرند و پاسخ‌ها را برمی‌گردانند. ویوها معمولاً یک فانکشن یا کلاس به همراه یک متود کلاسی مخصوص مثل ```()as_view``` هستند.

در هر دو مورد ما یک تابع پایتون معمولی میسازیم که ```HTTPRequest``` را به عنوان آرگومان اول می‌گیرد و ```HTTPResponse``` را به عنوان پاسخ برمی‌گرداند.
یک ```URLConf```(پیکربندی URL) نیز همچنین میتواند به عنوان آرگومان اضافه به این تابع فرستاده شود. این آرگومان‌ها می‌تواند از قسمتی از URL گرفته شود و یا مقدار آن به صورت پیشفرض معین شده باشد.

نمونه یک ویوی ساده به شکل زیر است:

```
# In views.py
from django.http import HttpResponse

def hello_fn(request, name="World"):
    return HttpResponse("Hello {}!".format(name))
```

هر دو خط تابع ویو ما انقدر ساده است که راحت میشه آن را متوجه شد. در حال حاضر ما هیچ کاری با آرگومان‌های درخواست فرستاده شده نداریم. میتونیم برای بهتر فهمیدن کانتکس که در کدام ویو صدا زده شده است، می‌توانیم درخواست را بررسی کنیم به طور مثال با نگاه کردن به پارامترهای ```GET/POST```، مسیر URI یا هدرهای HTTP مثل ```REMOTE_ADDR```.

تنظیم نقشه مسیرها در ```URLConf``` به صورت سنتی است که از عبارات منظم استفاده می‌شود که به صورت زیر است:

```
# In urls.py
    url(r'^hello-fn/(?P<name>\w+)/$', views.hello_fn),
    url(r'^hello-fn/$', views.hello_fn),
```
 
برای پشتیبانی کردن از دو الگوی URL میتوانیم از همان ویو مجدداً استفاده کنیم. الگوی اول یک نام را به عنوان آرگومان میگیرد. الگوی دوم هیچ آرگومانی را از URL نمیگیرد و تابع ویو از مقدار پیشفرض معین شده برای نام در این استفاده می‌کند.

وقتی شما از سینتکس مسیریابی شده که در جنگو 2.0 معرفی شد استفاده میکنید، ارسال پارامترها به طور یکسان کار میکند.پس شما نگاشت معادل آن را میتواند در ```viewschapter/urls.py``` پیدا کنید:

```
# In urls.py
    path('hello-fn/<str:name>/', views.hello_fn),
    path('hello-fn/', views.hello_fn),
```

ما در ادامه کتاب از سینتکس ساده شده استفاده می‌کنیم که خواندن آن راحت‌تر است.

### ویوهایی که کلاسی‌تر هستند

ویوهای بر اساس کلاس در جنگو 1.4 معرفی شدند. در اینجا ما معادل تابع ویو قبل را که دیدیم برای ویو بر اساس کلاس بازنویسی کرده‌ایم:

```
from django.views.generic import View


class HelloView(View):
    def get(self, request, name="World"):
        return HttpResponse("Hello {}!".format(name))
```

دوباره در اینجا متناظر با قبل در ```URLConf``` ما دو خط داریم که در زیر آمده است:

```
# In urls.py
    path('hello-cl/<str:name>/', views.HelloView.as_view()),
    path('hello-cl/', views.HelloView.as_view()),
```

چندین تفاوت جالب بین ویوهای بر اساس کلاس و تابع‌های ویو وجود دارد. چیزی که خیلی واضحه این که ما نیاز داریم اول کلاس را تعریف کنیم بعد ما باید صراحتاً فقط درخواست‌های ```GET``` را مدیریت کنیم. در تابع ویو قبلی برای ```POST ،GET``` یا دیگر پروتکل‌های HTTP همان پاسخ را دریافت می‌کنیم. همانطور که در دستورهای زیر از کلاینت در شل جنگو استفاده می‌کنیم:

```
>>> from django.test import Client
>>> c = Client()

>>> c.get("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.get("http://0.0.0.0:8000/hello-cl/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-cl/").content
Method Not Allowed (POST): /hello-cl/
b'
```

به یاد داشته باشید که متود ```POST``` دیگر غیرمجاز است به جای اینکه در سکوت نادیده گرفته شود. صریح بودن از نقطه نظر امنیت و نگه‌داری ویو خوب است.

مهمترین مزیت استفاده از کلاس این است که هنگام شخصی سازی ویو میتوانیم راحت‌تر آن را انجام دهیم. شما می‌توانید از یک کلاس عمومی ویو برای خوش آمدگویی بنویسید و خوش آمدگویی‌های اختصصاصی خود را نیز از آن استخراج کنید مثل زیر:

```
class GreetView(View):
    greeting = "Hello {}!"
    default_name = "World"
    def get(self, request, **kwargs):
        name = kwargs.pop("name", self.default_name)
        return HttpResponse(self.greeting.format(name))

class SuperVillainView(GreetView):
    greeting = "We are the future, {}. Not them. "
    default_name = "my friend"
```

پس ```URLConf``` نشأت گرفته از کلاس به صورت زیر است:

```
# In urls.py
    path('hello-su/<str:name>/', views.SuperVillainView.as_view()),
    path('hello-su/', views.SuperVillainView.as_view()),
```

در صورتی که شما بخواهید چند آرگومان کلمه کلیدی با مقادیر پیشفرضشان به تابع ویو اضافه کنید و شخصی سازی کنید در شیوه مشابه ممکن نیست و این میتونه غیر قابل مدیریت باشه.این دقیقاً همان دلیلی که ویوهای جنریک از تابع‌های ویو به ویوهای بر اساس کلاس مهاجرت کردند.

**جنگو رها شده(داستان)**

استیو بعد از صرف دو هفته زمان برای شکار کردن یه توسعه دهنده خوب جنگو شروع به فکر کردن خلاقانه و متفاوت کرد. متوجه شد که موفقیت بزرگ آن‌ها در رویداد هکاتون، او و هارت یک مسابقه *جنگوی رها شده* را در S.H.I.M سازماندهی کرده‌اند. قوانین آن‌ها بسیار ساده است: ساختن یک وب اپلیکیشن در یک روز. این ممکنه ساده باشه ولی شما نمیتونی یک روز را رد کنی یا زنجیر را بشکنی. هر کسی که طولانی‌ترین زنجیر را بسازه برنده است.

برنده، برد زانی یک سوپرایز واقعی بود. اون یک طراح سنتی بود که هیچ سررشته‌ای از برنامه نویسی نداشت. اون فقط یک بار در کلاس آموزشی یک هفته‌ای جنگو فقط برای ضربه زدن شرکت کرده بود. اون یک زنجیره ناگسستنی از 21 سایت جنگو که همه از صفر ساخته شده بودند را مدیریت کرد.

استیو همان روز بعدش با او ساعت 10 در دفترش قرار ملاقاتی گذاشت. اگر که برد نمیدانست که در فرآیند استخدام قرار گرفته است. در زمان مقرر شده ضربه آرامی شنیده شد و پسری لاغر و ریشو که اواخر بیست سالگی بود وارد شد. همانطور که آن‍ها صحبت میکردند، برد هیچ تظاهری به واقعیت نکرد که یک برنامه‌نویس نیست. در واقع برای او هیچ تظاهر کردنی نبود. با چشمان آرام آبیش به عینک ضخیمش نگاهی انداخت و توضیح داد که رازش خیلی ساده بوده؛ الهام بگیر و تمرکز کن.

او روزش را با یک وایرفریم(طرح اولیه) ساده شروع میکرد بعد می‌خواست یک پروژه جنگو خالی با قالب بوت استرپ توئیتر بسازد. اون ویوهای جنریک بر اساس کلاس جنگو را پیدا کرد که راه عالی‌ای برای بدون به سختی کد نوشتنی برای ساختن ویوها بود. بعضی اوقات او از یک یا دو میکسین‌های جنگو استفاده میکرد و همچنین رابط پنل مدیریت جنگو را برای اضافه کردن داده در هنگام کار کردن دوست داشت.

پروژه مورد علاقه‌اش Labyrinth بود؛ یک هانی پات که به فروم بیس بال مبدل شده بود. او حتی توانست چندین ربات نظارتی که در حال شکار سایت‌های آسیب پذیر بودند را نیز به دام بیاندازد. وقتی که استیو درباره پروژه سوپر کتاب به او توضیح داد، اون خیلی بیشتر خوشحال شد که این پیشنهاد را قبول کنه. ایده ساخت شبکه اجتماعی میان ستاره‌ای واقعاً او را مجذوب خود کرد. با یکمی گشت و گذار بیشتر، استیو میتوانست چند ده پروفایل جذاب مثل برد را در S.H.I.M پیدا کند. او یاد گرفت که در وهله اول به جای گشتن در خارج از مجموعه، بهتر است که اول در داخل سازمان جستجو کند.

# ویوها و URLها

در این فصل ما در مورد مباحث زیر بحث خواهیم کرد:

- ویوهای بر اساس کلاس و بر اساس فانکشن
- میکسین‌ها
- دکوراتورها
- الگوهای مرسوم ویو
- طراحی کردن URLها
- کار کردن با ری‌اکت و دیگر فرانت‌اندهای جاوا اسکریپت

## نگاه از بالا به ویو

در جنگو، ویوها به عنوان فراخوانی کننده تعریف می‌شوند که درخواست‌ها را میپذیرند و پاسخ‌ها را برمی‌گردانند. ویوها معمولاً یک فانکشن یا کلاس به همراه یک متود کلاسی مخصوص مثل ```()as_view``` هستند.

در هر دو مورد ما یک تابع پایتون معمولی میسازیم که ```HTTPRequest``` را به عنوان آرگومان اول می‌گیرد و ```HTTPResponse``` را به عنوان پاسخ برمی‌گرداند.
یک ```URLConf```(پیکربندی URL) نیز همچنین میتواند به عنوان آرگومان اضافه به این تابع فرستاده شود. این آرگومان‌ها می‌تواند از قسمتی از URL گرفته شود و یا مقدار آن به صورت پیشفرض معین شده باشد.

نمونه یک ویوی ساده به شکل زیر است:

```
# In views.py
from django.http import HttpResponse

def hello_fn(request, name="World"):
    return HttpResponse("Hello {}!".format(name))
```

هر دو خط تابع ویو ما انقدر ساده است که راحت میشه آن را متوجه شد. در حال حاضر ما هیچ کاری با آرگومان‌های درخواست فرستاده شده نداریم. میتونیم برای بهتر فهمیدن کانتکس که در کدام ویو صدا زده شده است، می‌توانیم درخواست را بررسی کنیم به طور مثال با نگاه کردن به پارامترهای ```GET/POST```، مسیر URI یا هدرهای HTTP مثل ```REMOTE_ADDR```.

تنظیم نقشه مسیرها در ```URLConf``` به صورت سنتی است که از عبارات منظم استفاده می‌شود که به صورت زیر است:

```
# In urls.py
    url(r'^hello-fn/(?P<name>\w+)/$', views.hello_fn),
    url(r'^hello-fn/$', views.hello_fn),
```
 
برای پشتیبانی کردن از دو الگوی URL میتوانیم از همان ویو مجدداً استفاده کنیم. الگوی اول یک نام را به عنوان آرگومان میگیرد. الگوی دوم هیچ آرگومانی را از URL نمیگیرد و تابع ویو از مقدار پیشفرض معین شده برای نام در این استفاده می‌کند.

وقتی شما از سینتکس مسیریابی شده که در جنگو 2.0 معرفی شد استفاده میکنید، ارسال پارامترها به طور یکسان کار میکند.پس شما نگاشت معادل آن را میتواند در ```viewschapter/urls.py``` پیدا کنید:

```
# In urls.py
    path('hello-fn/<str:name>/', views.hello_fn),
    path('hello-fn/', views.hello_fn),
```

ما در ادامه کتاب از سینتکس ساده شده استفاده می‌کنیم که خواندن آن راحت‌تر است.

### ویوهایی که کلاسی‌تر هستند

ویوهای بر اساس کلاس در جنگو 1.4 معرفی شدند. در اینجا ما معادل تابع ویو قبل را که دیدیم برای ویو بر اساس کلاس بازنویسی کرده‌ایم:

```
from django.views.generic import View


class HelloView(View):
    def get(self, request, name="World"):
        return HttpResponse("Hello {}!".format(name))
```

دوباره در اینجا متناظر با قبل در ```URLConf``` ما دو خط داریم که در زیر آمده است:

```
# In urls.py
    path('hello-cl/<str:name>/', views.HelloView.as_view()),
    path('hello-cl/', views.HelloView.as_view()),
```

چندین تفاوت جالب بین ویوهای بر اساس کلاس و تابع‌های ویو وجود دارد. چیزی که خیلی واضحه این که ما نیاز داریم اول کلاس را تعریف کنیم بعد ما باید صراحتاً فقط درخواست‌های ```GET``` را مدیریت کنیم. در تابع ویو قبلی برای ```POST ،GET``` یا دیگر پروتکل‌های HTTP همان پاسخ را دریافت می‌کنیم. همانطور که در دستورهای زیر از کلاینت در شل جنگو استفاده می‌کنیم:

```
>>> from django.test import Client
>>> c = Client()

>>> c.get("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-fn/").content
b'Hello World!'

>>> c.get("http://0.0.0.0:8000/hello-cl/").content
b'Hello World!'

>>> c.post("http://0.0.0.0:8000/hello-cl/").content
Method Not Allowed (POST): /hello-cl/
b'
```

به یاد داشته باشید که متود ```POST``` دیگر غیرمجاز است به جای اینکه در سکوت نادیده گرفته شود. صریح بودن از نقطه نظر امنیت و نگه‌داری ویو خوب است.

مهمترین مزیت استفاده از کلاس این است که هنگام شخصی سازی ویو میتوانیم راحت‌تر آن را انجام دهیم. شما می‌توانید از یک کلاس عمومی ویو برای خوش آمدگویی بنویسید و خوش آمدگویی‌های اختصصاصی خود را نیز از آن استخراج کنید مثل زیر:

```
class GreetView(View):
    greeting = "Hello {}!"
    default_name = "World"
    def get(self, request, **kwargs):
        name = kwargs.pop("name", self.default_name)
        return HttpResponse(self.greeting.format(name))

class SuperVillainView(GreetView):
    greeting = "We are the future, {}. Not them. "
    default_name = "my friend"
```

پس ```URLConf``` نشأت گرفته از کلاس به صورت زیر است:

```
# In urls.py
    path('hello-su/<str:name>/', views.SuperVillainView.as_view()),
    path('hello-su/', views.SuperVillainView.as_view()),
```

در صورتی که شما بخواهید چند آرگومان کلمه کلیدی با مقادیر پیشفرضشان به تابع ویو اضافه کنید و شخصی سازی کنید در شیوه مشابه ممکن نیست و این میتونه غیر قابل مدیریت باشه.این دقیقاً همان دلیلی که ویوهای جنریک از تابع‌های ویو به ویوهای بر اساس کلاس مهاجرت کردند.

**جنگو رها شده(داستان)**

استیو بعد از صرف دو هفته زمان برای شکار کردن یه توسعه دهنده خوب جنگو شروع به فکر کردن خلاقانه و متفاوت کرد. متوجه شد که موفقیت بزرگ آن‌ها در رویداد هکاتون، او و هارت یک مسابقه *جنگوی رها شده* را در S.H.I.M سازماندهی کرده‌اند. قوانین آن‌ها بسیار ساده است: ساختن یک وب اپلیکیشن در یک روز. این ممکنه ساده باشه ولی شما نمیتونی یک روز را رد کنی یا زنجیر را بشکنی. هر کسی که طولانی‌ترین زنجیر را بسازه برنده است.

برنده، برد زانی یک سوپرایز واقعی بود. اون یک طراح سنتی بود که هیچ سررشته‌ای از برنامه نویسی نداشت. اون فقط یک بار در کلاس آموزشی یک هفته‌ای جنگو فقط برای ضربه زدن شرکت کرده بود. اون یک زنجیره ناگسستنی از 21 سایت جنگو که همه از صفر ساخته شده بودند را مدیریت کرد.

استیو همان روز بعدش با او ساعت 10 در دفترش قرار ملاقاتی گذاشت. اگر که برد نمیدانست که در فرآیند استخدام قرار گرفته است. در زمان مقرر شده ضربه آرامی شنیده شد و پسری لاغر و ریشو که اواخر بیست سالگی بود وارد شد. همانطور که آن‍ها صحبت میکردند، برد هیچ تظاهری به واقعیت نکرد که یک برنامه‌نویس نیست. در واقع برای او هیچ تظاهر کردنی نبود. با چشمان آرام آبیش به عینک ضخیمش نگاهی انداخت و توضیح داد که رازش خیلی ساده بوده؛ الهام بگیر و تمرکز کن.

او روزش را با یک وایرفریم(طرح اولیه) ساده شروع میکرد بعد می‌خواست یک پروژه جنگو خالی با قالب بوت استرپ توئیتر بسازد. اون ویوهای جنریک بر اساس کلاس جنگو را پیدا کرد که راه عالی‌ای برای بدون به سختی کد نوشتنی برای ساختن ویوها بود. بعضی اوقات او از یک یا دو میکسین‌های جنگو استفاده میکرد و همچنین رابط پنل مدیریت جنگو را برای اضافه کردن داده در هنگام کار کردن دوست داشت.

پروژه مورد علاقه‌اش Labyrinth بود؛ یک هانی پات که به فروم بیس بال مبدل شده بود. او حتی توانست چندین ربات نظارتی که در حال شکار سایت‌های آسیب پذیر بودند را نیز به دام بیاندازد. وقتی که استیو درباره پروژه سوپر کتاب به او توضیح داد، اون خیلی بیشتر خوشحال شد که این پیشنهاد را قبول کنه. ایده ساخت شبکه اجتماعی میان ستاره‌ای واقعاً او را مجذوب خود کرد. با یکمی گشت و گذار بیشتر، استیو میتوانست چند ده پروفایل جذاب مثل برد را در S.H.I.M پیدا کند. او یاد گرفت که در وهله اول به جای گشتن در خارج از مجموعه، بهتر است که اول در داخل سازمان جستجو کند.

## ویوهای جنریک بر اساس کلاس

ویوهای جنریک بر اساس کلاس، ویوهای مرسومی برای پیاده سازی کردن به شیوه شئ گرا (مخصوصاً متود الگوی قالب) برای استفاده مجدد بهتر هستند. من از اطلاح ویوهای جنریک متنفرم و ترجیح میدم آن‌ها را **ویوهای استوک** صدا بزنم، مثل عکس‌های استوک. شما می‌توانید با کمی تغییر و تحول برای اکثر کارهای مرسومی که نیاز دارید از آن‌ها استفاده کنید.

ویوهای جنریک به این دلیل ساخته شده‌اند که توسعه دهنده‌های جنگو احساس میکردند که دارند همان نوع ویوها را در هر پروژه دوباره می‌سازند. تقریباً هر پروژه نیاز به یک صفحه داشت که لیستی از اشیاء(```ListView```)، جزیئات یک شئ(```DetailView```) یا فرمی برای ساختن یک شئ(```CreateView```) را نشان دهند. به دلیل اصل DRY(خودت را تکرار نکن)، این ویوهای با قابلیت استفاده مجدد با جنگو همراه شدند.

جدول مناسبی از ویوهای جنریک در جنگو 2.0 در زیر آمده است:

| توضیحات | نام کلاس | نوع کلاس |
| :---: | :---: | ---: |
|این ویو پدر تمام ویوها است که درستی(سلامت عقل) و ارسال(اعزام) را بررسی می‌کند.|View|پایه(base)|
|این ویو از قالب رندر میگیرد و کلمات کلیدی ```URLConf``` را در درون کانتکس قرار می‌دهد.|TemplateView|پایه(base)|
|این ویو هر درخواست ```GET``` را ریدایرکت می‌کند.|RedirectView|پایه(base)|
|این ویو از آیتم‌های قابل تکرار مثل ```queryset``` رندر میگیرد.|ListView|لیست(List)|
|این ویو، از آیتم بر اساس ```pk```(کلید اصلی) یا ```slug```(آدرس مخصوص آن آیتم) در ```URLConf``` رندر میگیرد.|DetailView|جزئیات(Detail)|
|این ویو از فرم رندر میگیرد و آن را پردازش می‌کند.|FormView|ویرایش(Edit)|
|این ویو از فرم رندر میگیرد و آن را برای ساخت یک شئ جدید پردازش می‌کند.|CreateView|ویرایش(Edit)|
|این ویو از فرم رندر میگیرد و آن را برای ویرایش کردن یک شئ پردازش می‌کند.|UpdateView|ویرایش(Edit)|
|این ویو از فرم رندر میگیرد و برای حذف کردن یک شئ آن را پردازش می‌کند.|DeleteView|ویرایش(Edit)|
|این ویو لیستی از اشیاء را با فیلد ```Date```(تاریخ) رندر میگیرد که آخرین شئ در اول قرار میگیرد و به همین ترتیب. |ArchiveIndexView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year```(سال) که توسط ```URLConf``` به آن داده می‌شود، رندر میگیرد.|YearArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year```(سال) و ```month```(ماه) رندر میگیرد.|MonthArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year```(سال) و شماره ```week```(هفته) رندر میگیرد.|WeekArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء را با فیلد ```Year, month```(سال، ماه) و ```Day```(روز) رندر میگیرد.|DayArchiveView|تاریخ(Date)|
|این ویو لیستی از اشیاء که تاریخ آن‌ها، امروز است را رندر میگیرد.|TodayArchiveView|تاریخ(Date)|
|این ویو شئ‌ای را که با فیلدهای ```Year, month```(سال، ماه) و ```day```(روز) که بر اساس ```pk```(کلید اصلی) یا ```slug```(آدرس مخصوص آن آیتم) مشخص شده است را رندر می‌گیرد.|DateDetailView|تاریخ(Date)|
|این ویو فرم ورود را رندر میگیرد و فرآیند وارد شدن را مدیریت می‌کند.|LoginView|احراز هویت(Auth)|
|این ویو کاربرانی که قبلاً وارد شده اند و هنوز از حساب خود خارج نشده‌اند را خارج کرده و پیام **شما خارج شدید** را به آن‌ها نشان می‌دهد.|LogoutView|احراز هویت(Auth)|
|این مجموعه‌ای از شش ویو است که جریان کار فراموشی رمز عبور و تغییر آن را مدیریت می‌کند.|Password*View|احراز هویت(Auth)|

ما کلاس‌های پایه مثل ```BaseDetailView``` یا میکسین‌ها مانند ```SingleObjectMixin``` اینجا ذکر نکردیم. آن‌ها به عنوان کلاس‌های پدر طراحی شده‌اند و در بیشتر موارد، شما از آن‌ها به صورت مستقیم استفاده نمی‌کنید.

من قویاً توصیه میکنم که مناسب‌ترین ویوی جنریک را انتخاب کنید. به طور مثال به جای استفاده از ```ListView``` می‌توانید همان ویو را با استفاده از ```TemplateView``` پیاده سازی کنید یا حتی ```View```. هر چند که اینطور شما اکثر مزیت‌های استفاده کردن از ویوهای جنریک را از دست می‌دهید.

پس خودتان را با این جدول آشنا کنید و ویو جنریکی که با توجه به نیازتان، بیشترین تطابق را دارد انتخاب کنید. بهترین منبع برای ویوهای جنریک بر اساس کلاس درجه یک به آدرس <http://ccbv.co.uk/> است(اکثر توسعه دهندگان جنگو این آدرس را بخاطر دارند). شما تمام ویژگی‌ها و متودهای هر یک از ویوهایی که اینجا ذکر شد را پیدا خواهید کرد.

### ویوهای بر اساس کلاس همیشه جنریک ویوهای بر اساس کلاس نیستند

اکثر افراد بین ویوهای بر اساس کلاس با ویوهای جنریک بر اساس کلاس گیج می‌شوند. اسم‌های آن‌ها بهم شبیه است ولی یکی نیستند. این منجر به برخی ```misconceptions```(تصورات غلط) شده که در زیر آمده است:

- **فقط ویوهای جنریک هستند که با جنگو همراه شده‌اند**: خوشبختانه این اشتباه است. هیچ جادوی خاصی در ویوهای جنریک بر اساس کلاس نیست که ارائه شده باشد.

شما آزادید که مجموعه ویوهای جنریک بر اساس کلاس خود را منتشر کنید همچنین می‌توانید از کتابخانه‌های واسط مثل```django-vanilla-views```(<http://django-vanilla-views.org/>) فلان استفاده کنید که پیاده‌سازی ساده‌تری نسبت به ویوهای جنریک استاندارد دارند. به خاطر داشته باشید که استفاده از ویوهای جنریک شخصی‌سازی شده ممکن است که کد شما را برای بقیه ناآشنا کند.
- **ویوهای بر اساس کلاس همیشه باید از ویوهای جنریک استخراج شوند**: دوباره میگویم، هیچ چیز جادویی ویوهای جنریک بر اساس کلاس وجود ندارد. اگر چه 90 درصد اوقات، شما کلاس جنریکی مثل ```View``` را پیدا می‌کنید که برای استفاده به عنوان کلاس پایه ایده‌آل است. شما آزادید که ویژگی‌های مشابه خودتان را پیاده‌سازی کنید.

## میکسین‌های ویو

میکسین‌ها ذات کدهای DRY در ویوهای بر اساس کلاس هستند. میکسین‌های ویو نیز مثل میکسین‌های مدل، از مزیت ارث‌بری چندگانه پایتون برای استفاده مجدد تکه‌های عملکرد استفاده می‌کنند. آن‌ها اغلب کلاس‌های بدون پدر در پایتون 3 هستند(یا اگر چه این‌ها کلاس‌های سبک جدید هستند از کلاس ```object``` در پایتون 2 استخراج شده‌اند).

میکسین‌ها پردازش‌های ویو را که در جای خوب تعریف شده باشند پیگیری میکنند. به طور مثال اکثر ویوهای جنریک از ```get_context_data``` استفاده میکنند که دیکشنری کانتکس را با آن تنظیم کنند. کلاس مشتق شده یا میکسین‌ها میتوانند متغیر کانتکس اضافه را به آن اضافه کنند. برای مثال ```feed``` حاوی فیدهای کاربران درباره پست‌ها است. در زیر میکسین آن که ممکن است چگونه باشد آمده است:

```
class FeedMixin:
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["feed"] = models.Post.objects.viewable_posts(
            self.request.user)
        return context
```

متود ```get_context_data``` در ابتدا کانتکس‌های همنام خود را در تمامی کلاس‌های پایه فراخوانی کرده و تجمیع می‌کند. بعد مقدار دیکشنری کانتکس را با متغیر ```feed``` بروزرسانی می‌کند.

حالا با قرار گرفتن آن در لیست کلاس های پایه می‌توان از این میکسین برای افزودن فید کاربر استفاده کرد. اگر سوپر کتاب به یک صفحه اصلی شبکه اجتماعی معمولی با یک فرم برای ساختن یک پست بر اساس فید شما نیاز دارد، می‌تواند از این میکسین که در زیر آمده استفاده کند:

```
class MyFeed(FeedMixin, generic.CreateView):
    model = models.Post
    template_name = "myfeed.html"
    success_url = reverse_lazy("my_feed")
```

یک میکسین که خوب نوشته شده باشد الزامات خیلی کمی دارد. باید انقدر انعطاف پذیر باشد که در اکثر موقعیت‌ها مفید واقع شود. در مثال قبل، ```FeedMixin``` متغیر کانتکس ```feed``` را در کلاس مشتق شده بازنویسی خواهد کرد. اگر یک کلاس پدر از متغیر کانتکس ```feed``` استفاده کند می‌تواند روی میکسین باعث ایجاد نقص شود. از این رو خیلی مفیدتر خواهد بود اگر یک متغیر کانتکس شخصی سازی شده جدید را بسازد مثل زیر:

```
class FeedMixin(object):
    feed_context_name = "feed"

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context[self.feed_context_name] = 
            models.Post.objects.viewable_posts(self.request.user)
        return context
```

توانانی ترکیب کردن میکسین‌ها با بقیه کلاس‌ها هم براشون بزرگترین مزیت است و هم بزرگترین عیب. اشتباه ترکیب کردن آن‌ها می‌تواند به نتایج عجیب و غریب منجر شود. پس قبل از استفاده از میکسین نیاز دارید که اطمینان حاصل کنید که سورس کد میکسین و بقیه کلاس‌ها، درگیری‌ای با متودها یا متغیرهای کانتکس نداشته باشند.

### ترتیبی از میکسین‌ها

شما ممکن است با کدهایی مواجه شده باشید که چندین میکسین به صورت زیر داشته‌اند:

```
class ComplexView(MyMixin, YourMixin, AccessMixin, DetailView):
```

پی بردن به ترتیب لیست کلاس‌های پایه می‌تواند بسیار مشکل باشد. مثل اکثر چیزها در پایتون، قوانین عادی پایتون اعمال می‌شود. **Method Resolution Order (MRO)** پایتون معین می‌کند که آن‌ها چطور باید مرتب شوند.

مخلص کلام این است که میکسین‌ها اول بیایند و کلاس‌های پایه، آخر. هر چی کلاس پدر تخصصی‌تر باشه باید چپ تر قرار بگیره. در عمل این تنها قانونی است که باید یادتون بمونه. 

برای اینکه متوجه بشید که چرا اینجوری کار میکنه به مثال ساده زیر توجه کنید:

```
class A:
    def do(self):
        print("A")


class B:
    def do(self):
        print("B")


class BA(B, A):
    pass


class AB(A, B):
    pass


BA().do() # Prints B
AB().do() # Prints A
```

همانطور که شما انتظار دارید اگر در لیست کلاس‌های پایه ```B``` قبل از ```A``` ذکر شده بود، متود ```B``` صدا زده میشد و بالعکس.

حالا تصور کنید که ```A``` کلاس پایه‌ای مثل ```CreateView``` باشد و ```B``` میکسینی مثل ```FeedMixin```. یک میکسین عملکرد پایه‌ای یک کلاس پایه را بیش از پیش افزایش می‌دهد. از این رو باید کد میکسین اول عمل کند و به نوبه خود اگر نیاز بود کلاس پایه هم صدا زده شود. پس ترتیب درست، ```BA```(میکسین اول، پایه آخر) است.

ترتیب اینکه مشخص کنیم چطور کلاس‌های پایه را صدا بزنیم می‌تواند با چک کردن ویژگی ```__mro__``` کلاس بررسی شود:

```
>>> AB.__mro__
 (<class 'AB'>, <class 'A'>, <class 'B'>, <class 'object'>)
```

پس اگر ```AB``` متود ```super()``` را صدا بزند، اول ```A``` فراخوانی می‌شود؛ بعد متود ```super()``` کلاس ```A```، کلاس ```B``` را صدا خواهد زد و به همین ترتیب.


**نکته(TIP)**

معمولاً MRO پایتون به ترتیب در مرحله اول، از عمق شروع میکند و در مرحله دوم از چپ به راست را برای انتخاب متود در سلسله مراتب کلاس‌ها دنبال می‌کند. جزئیات بیشتر میتواند در <http://www.python.org/download/releases/2.3/mro/> پیدا شود.

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## دکوراتورها

قبل از ویوهای بر اساس کلاس، دکوراتورها تنها راه برای تغییر رفتار ویوهای بر اساس تابع بودند. از آنجایی که اطراف یک تابع قرار دارند نمیتوانستند عملکرد ویو را تغییر دهند و بنابراین به طور موثر با آن، مثل جعبه‌ای که از درونش خبر ندارند رفتار میکردند. 

یک ```Decorator(دکوراتور)``` تابعی است که تابعی را میگیرد و یک تابع دکوراتور شده را برمیگرداند. گیج شدید؟ یک سری کد وجود دارد که به شما کمک می‌کند این مسئله را بهتر متوجه شوید. استفاده از علامت ```@``` برای نشان دادن دکوراتور است، همانطور که در زیر دکوراتور ```login_required``` نشان داده شده است:

```
@login_required
def simple_view(request):
    return HttpResponse()
```

کدی که در ادامه آمده دقیقاً همان کد قبلی است:

```
def simple_view(request):
    return HttpResponse()

simple_view = login_required(simple_view)
```

از آنجایی که ```login_required``` اطراف ویو قرار گرفته، تابع اطراف گیرنده(wrapper)، کنترل تابع را بدست می‌گیرید. اگر کاربری وارد نشده باشد به ```settings.LOGIN_URL``` ریدایرکت می‌شود. در غیر اینصورت تابع ```simple_view``` را اجرا می‌کند انگار که اصلاً وجود نداشته است.

دکوراتورها انعطاف کمتری نسبت به میکسین‌ها دارند هرچند ساده‌ترند. شما می‌توانید از هر دو آنها یعنی دکوراتورها و میکسین‌ها استفاده کنید. در حقیقت، تعداد زیاد از میکسین‌ها با دکوراتورها پیاده‌سازی شده‌اند. 

## الگوهای ویو

بیاید چندتا از الگوهای طراحی دیده شده در طراحی ویو ببینیم.

### الگو - دسترسی به ویوهای کنترل شده

**مسئله**: صفحات نیاز دارند در صورت شروطی قابل دسترسی باشند چه کاربر وارد شده باشد، چه عضو باشد چه کارمند یا هر شرط دیگری.

**راه حل**: استفاده از میکسین‌ها یا دکوراتورها برای کنترل دسترسی به ویو.

#### جزئیات مسئله

اکثر وب سایت‌ها صفحاتی دارند که فقط اگر شما وارد شده باشید می‌توانید به آن دسترسی پیدا کنید. این مسلم است که بقیه صفحات در دسترس افراد ناشناس یا بیننده‌های عمومی است. اگر بیننده‌های ناشناس بخواهند تلاش کنند که به صفحاتی که باید کاربر وارد شده باشد دسترسی پیدا کنند، به صفحه ورود منتقل می‌شوند. در حالت ایده‌آل به این صورت است که بعد از وارد شدن دوباره به همان صفحه قبلی که میخواستند آن را ببینند منتقل شوند. 

به طور مشابه صفحاتی هستند که مسلماً فقط نوع خاصی از کاربران می‌توانند آن را ببینند. به طور مثال پنل مدیریت جنگو فقط برای کارمندان قابل دسترس است. اگر افراد غیر کارمند تلاش کنند که به صفحات مدیریت دسترسی پیدا کنند، به صفحه ورود منتقل می‌شوند.

در نهایت، صفحاتی هستند که اگر فقط دسترسی دیدن آن‌ها به ما اعطا شده باشد می‌توانیم آن‌ها را ببینیم. برای مثال توانایی ویرایش کردن یک نوشته باید فقط برای نویسنده آن قابل دسترس باشد. هر کس دیگری که بخواهد به این صفحه دسترسی پیدا کند باید خطای **دسترسی غیرمجاز** را ببیند.

#### جزئیات راه حل

دو راه برای کنترل دسترسی ویو وجود دارد:

1. به وسیله استفاده از دکوراتورها روی ویوهای بر اساس تابع یا ویوهای بر اساس کلاس:

```
@login_required(MyView.as_view())
```

2. به وسیله بازنویسی کردن متود ```dispatch``` ویوهای بر اساس کلاس از طریق میکسین:

```
from django.utils.decorators import method_decorator

class LoginRequiredMixin:
    @method_decorator(login_required)
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
```

3. ما واقعا اینجا نیازی به دکوراتورها نداریم. بهتون توصیه میشه که از حالت خیلی صریحتر زیر استفاده بشه:

```
class LoginRequiredMixin:

    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_authenticated():
            raise PermissionDenied
        return super().dispatch(request, *args, **kwargs)
```

وقتی شما خطای ```Permission Denied```(دسترسی غیر مجاز) را مطرح کنید. جنگو قالب ```403.html``` در دایرکتوری ریشه شما را نمایش می‌دهد یا در صورت نبود آن، صفحه استاندارد **403 Forbidden(403 ممنوع)** را نمایش می‌دهد.

البته شما به مجموعه‌ای از میکسین‌های قدرتمند و شخصی سازی شده برای پروژه‌های واقعی  نیاز دارید. پکیج ```django-braces``` (<https://github.com/brack3t/django-braces>) مجموعه‌ عالی از میکسین‌ها مخصوصاً برای کنترل کردن دسترسی به ویوها دارد.

در اینجا مثالی از استفاده آن برای کنترل دسترسی به ویو برای کاربران وارد شده و ناشناس آورده شده است:

```
from braces.views import LoginRequiredMixin, AnonymousRequiredMixin

class UserProfileView(LoginRequiredMixin, DetailView):
    # This view will be seen only if you are logged-in
    pass

class LoginFormView(AnonymousRequiredMixin, FormView):
    # This view will NOT be seen if you are loggedin
    authenticated_redirect_url = "/feed"
```

جنگو ```LoginRequiredMixin``` از آدرس ```django.contrib.auth.mixins``` را با پیاده سازی خودش آماده کرده است اما میکسینی برای محدود کردن ویو فقط برای کاربران ناشناس آماده نکرده است.

کاربران کارمند در جنگو فقط کاربرانی هستند که پرچم ```is_staff``` آن‌ها در مدل کاربر تنظیم شده است. شما می‌توانید میکسین پیش ساخته ```UserPassesTestMixin``` را صدا بزنید و استفاده که زیر مثال آن آمده است:

```
from django.contrib.auth.mixins import UserPassesTestMixin

class SomeStaffView(UserPassesTestMixin, TemplateView):
    def test_func(self, user):
        return user.is_staff
```

شما همچنین می‌توانید میکسین‌های خودتان را بسازید که بررسی‌های به خصوصی را انجام دهد مانند اینکه شئ‌ای توسط نویسنده‌اش ویرایش می‌شود یا خیر(با مقایسه‌ آن، با یوزرهای وارد شده)

```
class CheckOwnerMixin:
    # To be used with classes derived from SingleObjectMixin
    def get_object(self, queryset=None):
        obj = super().get_object(queryset)
        if not obj.owner == self.request.user:
            raise PermissionDenied
        return obj
```

توصیه می‌شود تا حد امکان به کاربران کمترین امتیاز برای اشیاء داده شود. به این اصل، **Principle of least privilege(اصل حداقل امتیاز)** گفته می‌شود. به عنوان بهترین شیوه، حتما مطمئن شوید که کدام کاربران یا گروه‌ها مطمئناً می‌توانند چه کارهایی روی اشیاء انجام دهند به جای دسترسی پیشفرضی که دارند.

### الگو - بهبود دهنده‌های کانتکس

**مسئله**: چندین ویو بر اساس ویوهای جنریک نیاز به همان متغیر کانتکس دارند.

**راه حل**: ساخت یک میکسین که مجموعه‌هایی از متغیر کانتکس را به اشتراک بگذارد.

#### جزئیات مسئله

قالب‌های جنگو فقط می‌توانند متغیرهایی را نمایش دهند که در دیکشنری کانتکس حاضر باشند. هرچند سایت‌ها نیاز دارند که همان اطلاعات در چندین صفحه باشد. برای نمونه، سایدباری که پست‌های اخیر را در فید شما نمایش می‌دهد ممکن است در چندین ویو نیاز باشد.

هرچند اگر از ویو جنریک بر اساس کلاس استفاده کنیم، فقط می‌توانیم مجموعه محدودی از متغیرهای کانتکس مربوط به آن مدل به خصوص استفاده کنیم. تنظیم کردن همان متغیر کانتکس در هر ویو پیروی کردن از اصل DRY نیست.

#### جزئیات راه حل

اکثر ویوهای جنریک بر اساس کلاس از ```ContextMixin``` مشتق شده‌اند که متود ```get_context_data``` را آماده کرده است و اکثر کلاس‌ها آن را بازنویسی می‌کنند و متغیرهای کانتکس خودشان را به آن اضافه می‌کنند. درحالی که بهترین شیوه بازنویسی این متود است؛ شمااول نیاز دارید ```get_context_data``` سوپر کلاس را صدا بزنید و بعد متغیرهای کانتکس خودتان را اضافه یا بازنویسی کنید.

ما می‌توانیم این حالت از میکسین‌ها را همانطور که در قبل دیدیم انتزاع کنیم:

```
class FeedMixin(object):
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context["feed"] = models.Post.objects.viewable_posts(
            self.request.user)
        return context
```

ما می‌توانیم این میکسین را به ویوهامان اضافه کرده و از متغیرهای کانتکس اضافه شده نیز در قالبمان استفاده کنیم. به خاطر داشته باشید که ما از مدیر مدل(model manager) تعریف شدۀ [فصل 3]('../../../03-%20Models/README.md) مدل‌ها، برای فیلتر کردن پست‌ها استفاده می‌کنیم.

راه حل خیلی عمومی‌تر استفاده از میکسین ```StaticContextMixin``` از پکیج ```django-braces``` برای متغیرهای کانتکس ایستا است. به طور مثال ما می‌توانیم متغیر کانتکس ```latest_profile``` را که آخرین کاربری که به اضافه شده است، را اضافه کنیم:

```
class CtxView(StaticContextMixin, generic.TemplateView):
    template_name = "ctx.html"
    static_context = {"latest_profile": Profile.objects.latest('pk')}
```

در اینجا ```static_context``` به معنای هرچیزی است که از یک درخواست تا به درخواست دیگر تغییری نمی‌کند. به این معنا که شما می‌توانید مجموعه‌هایی از پرس و جوها(```Querysets```) را به خوبی ذکر کنید. هر چند متغیر کانتکس فید ما به ```self.request.user``` نیاز دارد تا پست‌های قابل دیدن کاربر را بازیابی کند. از این رو نمی‌تواند به عنوان کانتکس ایستا در اینجا استفاده شود.

متقابلاً اگر کانتکس اشتراکی مقداری ایستا باشد و ویوی جنریک از ```ContextMixin``` مشتق شده باشد(که اکثرا همینطور است) پس آن‌ها هنگام صدا زدن ```as_view``` می‌توانند ذکر شوند. برای نمونه:

```
path('myfeed/', views.MyFeed.as_view(
    extra_context={'title': 'My Feed'})),
```

### الگو - سرویس‌ها

**مسئله**: اپلیکیشن‌ها به یک رابط ماشینی برای یک قابلیت یا اطلاعات خاص وب سایت شما نیاز دارند. دریافت و خراشیدن داده از صفحات HTML رندر شده می‌تواند کاری سخت و پرزحمت باشد. برعکس API تمام عیار(که در [فصل 8]('../../../08-%20Working%20Asynchronously/README.md)، *کار کردن به صورت ناهمزمان* پوشش داده شده است) که نیاز به یک اندپوینت واحد برای یک هدف خاص یا یکبار استفاده اشاره دارد. 

**راه حل**: یک سرویس سبک بسازید که داده را به حالت ماشین پسند برگرداند مثل JSON یا XML.


#### جزئیات مسئله

ما اغلب فراموش می‌کنیم که وب سایت‌ها فقط توسط انسان‌ها استفاده نمی‌شوند. درصد قابل توجهی از ترافیک وب از دیگر برنامه‌ها مثل خزنده‌ها، ربات‌ها، خراش دهنده‌ها می‌آید. گاهی اوقات شما نیاز دارید همچنین برنامه‌هایی را برای خودتان بنویسید که اطلاعاتی از سایت‌های دیگر را استخراج کند.

عموماً صفحات طراحی شده برای مصرف انسان‌ها برای استخراج مکانیکی سنگین و دست و پاگیر هستند. صفحات HTML دارای اطلاعاتی هستند که توسط نشانه گذاری احاطه شده است و نیاز به پاک سازی گسترده دارند. گاهی اوقات اطلاعات پراکنده شده است و نیاز به گردآوری و تبدیل این داده‌های پراکنده است.

یک رابط ماشینی برای این چنین موقعیت‌هایی ایده‌آل است. شما فقط نمی‌توانید دردسر استخراج اطلاعات را کاهش دهید اما می‌توانید مخلوطی از آن بسازید. طول عمر اپلیکیشن اگر عملکرد آن به شیوه‌ای ماشین پسند در معرض دید قرار گیرد به طور فزاینده‌ای افزایش می‌یابد.

#### جزئیات راه حل

در جنگو شما می‌توانید بدون استفاده پکیج‌های واسط یک سرویس پایه‌ بسازید. به جای رندر گرفتن HTML، شما می‌توانید داده سریالایز شده را در حالت JSON برگردانید.

برای مثال، ما می‌توانیم سرویس ساده‌ای بسازیم که پنج پست عمومی اخیر از سوپر کتاب را برمیگرداند:

```
from django.http import JsonResponse

class PublicPostJSONView(View):
    def get(self, request, *args, **kwargs):
        msgs = models.Post.objects.public_posts().values(
            "posted_by_id", "message")[:5]
        return JsonResponse(list(msgs), safe=False
```

اگر سعی کنیم که این ویو را بازیابی کنیم به جای پاسخ HTML، رشته JSON دریافت خواهیم کرد:

```
>>> from django.test import Client
>>> Client().get("http://0.0.0.0:8000/public/").content
b'[{"posted_by_id": 23, "message": "Hello!"},
   {"posted_by_id": 13, "message": "Feeling happy"},
   ...
```

توجه کنید که ما نمی‌توانیم متود ```QuerySet```(مجموعه پرس و جو) را مستقیماً برای رندر گرفتن پاسخ JSON قرار دهیم. آن باید لیست، دیکشنری یا هر نوع داده‌ای پیش ساخته پایتون باشد که بتواند توسط سریالایز JSON شناسایی شود. اگر شما هر نوع داده‌ای غیر از ```dict```(دیکشنری) را سریالایز کنید، نیاز دارید که پارامتر کلید ```safe``` را برابر ```False``` قرار دهید.

البته اگر بخواهید هر چیز پیچیده‌تری از یک API ساده بسازید نیاز به استفاده از پکیج‌هایی مثل Django REST framework(جنگو رست فریمورک) دارید. جنگو رست فریمورک از سریالایز کردن(و دیسریالایز کردن) ```QuerySet```(مجموعه پرس و جو)، احراز هویت، ایجاد API قابل مرور وب و بقیه ویژگی‌های ضروری برای ساخت API قدرتمند و تمام عیار نیاز دارید مراقبت می‌کند. ما این را در [فصل 9]('../../../09-%20Creating%20APIs/README.md) *ساختن APIها* پوشش داده‌ایم.

